{"version":3,"file":"GraphQLCodegenDataMasking.js","sourceRoot":"","sources":["../../src/masking/GraphQLCodegenDataMasking.ts"],"names":[],"mappings":"","sourcesContent":["import type { HKT } from \"@apollo/client/utilities\";\nimport type { IsAny } from \"@apollo/client/utilities/internal\";\n\nimport type {\n  ContainsFragmentsRefs,\n  RemoveFragmentName,\n  UnwrapFragmentRefs,\n} from \"./internal/types.js\";\nexport declare namespace GraphQLCodegenDataMasking {\n  export interface TypeOverrides {\n    FragmentType: HKTImplementation.FragmentType;\n    MaybeMasked: HKTImplementation.MaybeMasked;\n    Unmasked: HKTImplementation.Unmasked;\n  }\n  namespace HKTImplementation {\n    export interface FragmentType extends HKT {\n      arg1: unknown; // TData\n      return: GraphQLCodegenDataMasking.FragmentType<this[\"arg1\"]>;\n    }\n\n    export interface MaybeMasked extends HKT {\n      arg1: unknown; // TData\n      return: GraphQLCodegenDataMasking.MaybeMasked<this[\"arg1\"]>;\n    }\n\n    export interface Unmasked extends HKT {\n      arg1: unknown; // TData\n      return: GraphQLCodegenDataMasking.Unmasked<this[\"arg1\"]>;\n    }\n  }\n\n  export type FragmentType<TData> =\n    [TData] extends [{ \" $fragmentName\"?: infer TKey }] ?\n      TKey extends string ?\n        { \" $fragmentRefs\"?: { [key in TKey]: TData } }\n      : never\n    : never;\n\n  /**\n   * Unwraps the type to its masked type.\n   *\n   * @remarks\n   * GraphQL Codegen generates types as masked types. The implementation is an\n   * identity type.\n   */\n  export type MaybeMasked<TData> = TData;\n\n  /**\n   * Unmasks a type to provide its full result.\n   */\n  export type Unmasked<TData> =\n    true extends IsAny<TData> ? TData\n    : TData extends object ?\n      true extends ContainsFragmentsRefs<TData> ?\n        UnwrapFragmentRefs<RemoveFragmentName<TData>>\n      : TData\n    : TData;\n}\n"]}