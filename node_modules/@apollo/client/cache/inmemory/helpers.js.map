{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/cache/inmemory/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  compact,\n  createFragmentMap,\n  DeepMerger,\n  getFragmentDefinitions,\n  isArray,\n  isField,\n  isNonNullObject,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { InMemoryCacheConfig, NormalizedCache } from \"./types.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        id != null ? { id }\n        : _id != null ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (id == null && _id != null) {\n      id = _id;\n    }\n\n    if (id != null) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\" ?\n          id\n        : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  resultCaching: true,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference) ?\n      (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result) ?\n        result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"]}