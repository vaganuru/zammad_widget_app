{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/core/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { DocumentNode, FormattedExecutionResult } from \"graphql\";\nimport type {\n  NextNotification,\n  Observable,\n  ObservableNotification,\n} from \"rxjs\";\n\nimport type { ApolloCache } from \"@apollo/client/cache\";\nimport type { Cache } from \"@apollo/client/cache\";\nimport type { ClientAwarenessLink } from \"@apollo/client/link/client-awareness\";\nimport type { Unmasked } from \"@apollo/client/masking\";\nimport type { DeepPartial, HKT } from \"@apollo/client/utilities\";\nimport type {\n  ApplyHKTImplementationWithDefault,\n  IsAny,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nexport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\n\nexport interface TypeOverrides {}\n\ndeclare namespace OverridableTypes {\n  export interface Defaults {\n    Complete: Complete;\n    Streaming: Streaming;\n    Partial: Partial;\n  }\n\n  interface Complete extends HKT {\n    arg1: unknown; // TData\n    return: this[\"arg1\"];\n  }\n\n  interface Streaming extends HKT {\n    arg1: unknown; // TData\n    return: this[\"arg1\"];\n  }\n\n  interface Partial extends HKT {\n    arg1: unknown; // TData\n    return: DeepPartial<this[\"arg1\"]>;\n  }\n}\n\nexport declare namespace DataValue {\n  /**\n   * Returns a representation of `TData` in it's \"complete\" state.\n   *\n   * @defaultValue `TData` if no overrides are provided.\n   *\n   * @example\n   * You can override this type globally - this example shows how to override it\n   * with `DeepPartial<TData>`:\n   *\n   * ```ts\n   * import { HKT, DeepPartial } from \"@apollo/client/utilities\";\n   *\n   * type CompleteOverride<TData> =\n   *   TData extends { _complete?: infer _Complete } ? _Complete : TData;\n   *\n   * interface CompleteOverrideHKT extends HKT {\n   *   return: CompleteOverride<this[\"arg1\"]>;\n   * }\n   *\n   * declare module \"@apollo/client\" {\n   *   export interface TypeOverrides {\n   *     Complete: CompleteOverrideHKT;\n   *   }\n   * }\n   * ```\n   */\n  export type Complete<TData> = ApplyHKTImplementationWithDefault<\n    TypeOverrides,\n    \"Complete\",\n    OverridableTypes.Defaults,\n    TData\n  >;\n\n  /**\n   * Returns a representation of `TData` while it is streaming.\n   *\n   * @defaultValue `TData` if no overrides are provided.\n   *\n   * @example\n   * You can override this type globally - this example shows how to override it\n   * with `DeepPartial<TData>`:\n   *\n   * ```ts\n   * import { HKT, DeepPartial } from \"@apollo/client/utilities\";\n   *\n   * type StreamingOverride<TData> = DeepPartial<TData>;\n   *\n   * interface StreamingOverrideHKT extends HKT {\n   *   return: StreamingOverride<this[\"arg1\"]>;\n   * }\n   *\n   * declare module \"@apollo/client\" {\n   *   export interface TypeOverrides {\n   *     Streaming: StreamingOverrideHKT;\n   *   }\n   * }\n   * ```\n   */\n  export type Streaming<TData> = ApplyHKTImplementationWithDefault<\n    TypeOverrides,\n    \"Streaming\",\n    OverridableTypes.Defaults,\n    TData\n  >;\n\n  /**\n   * Returns a representation of `TData` while it is partial.\n   *\n   * @defaultValue `DeepPartial<TData>` if no overrides are provided.\n   *\n   * @example\n   * You can override this type globally - this example shows how to override it\n   * with `DeepPartial<TData>`:\n   *\n   * ```ts\n   * import { HKT, DeepPartial } from \"@apollo/client/utilities\";\n   *\n   * type PartialOverride<TData> = DeepPartial<Complete<TData>>;\n   *\n   * interface PartialOverrideHKT extends HKT {\n   *   return: PartialOverride<this[\"arg1\"]>;\n   * }\n   *\n   * declare module \"@apollo/client\" {\n   *   export interface TypeOverrides {\n   *     Partial: PartialOverrideHKT;\n   *   }\n   * }\n   * ```\n   */\n  export type Partial<TData> = ApplyHKTImplementationWithDefault<\n    TypeOverrides,\n    \"Partial\",\n    OverridableTypes.Defaults,\n    TData\n  >;\n}\n\nexport interface DefaultContext extends Record<string, any> {\n  /**\n   * Indicates whether `queryDeduplication` was enabled for the request.\n   */\n  queryDeduplication?: boolean;\n  clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;\n}\n\n/**\n * Represents an `Error` type, but used throughout Apollo Client to represent\n * errors that may otherwise fail `instanceof` checks if they are cross-realm\n * Error instances (see the [`Error.isError` proposal](https://github.com/tc39/proposal-is-error) for more details).\n *\n * Apollo Client uses several types of errors throughout the client which can be\n * narrowed using `instanceof`:\n *\n * - `CombinedGraphQLErrors` - `errors` returned from a GraphQL result\n * - `CombinedProtocolErrors` - Transport-level errors from multipart subscriptions.\n * - `ServerParseError` - A JSON-parse error when parsing the server response.\n * - `ServerError` - A non-200 server response.\n *\n * @example\n *\n * ```ts\n * import { CombinedGraphQLErrors } from \"@apollo/client\";\n *\n * try {\n *   await client.query({ query });\n * } catch (error) {\n *   // Use `instanceof` to check for more specific types of errors.\n *   if (error instanceof CombinedGraphQLErrors) {\n *     error.errors.map((graphQLError) => console.log(graphQLError.message));\n *   } else {\n *     console.error(errors);\n *   }\n * }\n * ```\n */\nexport interface ErrorLike {\n  message: string;\n  name: string;\n  stack?: string;\n}\n\nexport type OnQueryUpdated<TResult> = (\n  observableQuery: ObservableQuery<any>,\n  diff: Cache.DiffResult<any>,\n  lastDiff: Cache.DiffResult<any> | undefined\n) => boolean | TResult;\n\nexport type RefetchQueryDescriptor = string | DocumentNode;\nexport type InternalRefetchQueryDescriptor =\n  | RefetchQueryDescriptor\n  | ApolloClient.QueryOptions;\n\ntype RefetchQueriesIncludeShorthand = \"all\" | \"active\";\n\nexport type RefetchQueriesInclude =\n  | RefetchQueryDescriptor[]\n  | RefetchQueriesIncludeShorthand;\n\nexport type InternalRefetchQueriesInclude =\n  | InternalRefetchQueryDescriptor[]\n  | RefetchQueriesIncludeShorthand;\n\n// The client.refetchQueries method returns a thenable (PromiseLike) object\n// whose result is an array of Promise.resolve'd TResult values, where TResult\n// is whatever type the (optional) onQueryUpdated function returns. When no\n// onQueryUpdated function is given, TResult defaults to ApolloQueryResult<any>\n// (thanks to default type parameters for client.refetchQueries).\nexport type RefetchQueriesPromiseResults<TResult> =\n  // If onQueryUpdated returns any, all bets are off, so the results array must\n  // be a generic any[] array, which is much less confusing than the union type\n  // we get if we don't check for any. I hoped `any extends TResult` would do\n  // the trick here, instead of IsStrictlyAny, but you can see for yourself what\n  // fails in the refetchQueries tests if you try making that simplification.\n  IsAny<TResult> extends true ? any[]\n  : // If the onQueryUpdated function passed to client.refetchQueries returns true\n  // or false, that means either to refetch the query (true) or to skip the\n  // query (false). Since refetching produces an ApolloQueryResult<any>, and\n  // skipping produces nothing, the fully-resolved array of all results produced\n  // will be an ApolloQueryResult<any>[], when TResult extends boolean.\n  TResult extends boolean ? ApolloClient.QueryResult<any>[]\n  : // If onQueryUpdated returns a PromiseLike<U>, that thenable will be passed as\n  // an array element to Promise.all, so we infer/unwrap the array type U here.\n  TResult extends PromiseLike<infer U> ? U[]\n  : // All other onQueryUpdated results end up in the final Promise.all array as\n    // themselves, with their original TResult type. Note that TResult will\n    // default to ApolloQueryResult<any> if no onQueryUpdated function is passed\n    // to client.refetchQueries.\n    TResult[];\n\n// Used by QueryManager[\"refetchQueries\"]\nexport interface InternalRefetchQueriesOptions<\n  TCache extends ApolloCache,\n  TResult,\n> extends Omit<ApolloClient.RefetchQueriesOptions<TCache, TResult>, \"include\"> {\n  // Just like the refetchQueries option for a mutation, an array of strings,\n  // DocumentNode objects, and/or QueryOptions objects, or one of the shorthand\n  // strings \"all\" or \"active\", to select every (active) query.\n  include?: InternalRefetchQueriesInclude;\n  // This part of the API is a (useful) implementation detail, but need not be\n  // exposed in the public client.refetchQueries API (above).\n  removeOptimistic?: string;\n}\n\nexport type InternalRefetchQueriesResult<TResult> =\n  // If onQueryUpdated returns a boolean, that's equivalent to refetching the\n  // query when the boolean is true and skipping the query when false, so the\n  // internal type of refetched results is Promise<ApolloQueryResult<any>>.\n  TResult extends boolean ? Promise<ApolloClient.QueryResult<any>>\n  : // Otherwise, onQueryUpdated returns whatever it returns. If onQueryUpdated is\n    // not provided, TResult defaults to Promise<ApolloQueryResult<any>> (see the\n    // generic type parameters of client.refetchQueries).\n    TResult;\n\nexport type InternalRefetchQueriesMap<TResult> = Map<\n  ObservableQuery<any>,\n  InternalRefetchQueriesResult<TResult>\n>;\n\nexport type OperationVariables = Record<string, any>;\n\nexport type DataState<TData> =\n  | {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n      data: DataValue.Complete<TData>;\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n      dataState: \"complete\";\n    }\n  | {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n      data: DataValue.Streaming<TData>;\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n      dataState: \"streaming\";\n    }\n  | {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n      data: DataValue.Partial<TData>;\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n      dataState: \"partial\";\n    }\n  | {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n      data: undefined;\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n      dataState: \"empty\";\n    };\n\nexport type GetDataState<\n  TData,\n  TState extends DataState<TData>[\"dataState\"],\n> = Extract<DataState<TData>, { dataState: TState }>;\n\n/**\n * Represents a result that might be complete or still streaming and\n * has been normalized into a plain GraphQL result. When the result is\n * still `streaming`, some fields might not yet be available.\n */\nexport type NormalizedExecutionResult<\n  TData = Record<string, unknown>,\n  TExtensions = Record<string, unknown>,\n> = Omit<FormattedExecutionResult<TData, TExtensions>, \"data\"> &\n  GetDataState<TData, \"streaming\" | \"complete\">;\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: NormalizedExecutionResult<Unmasked<T>>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  }\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport type MutationUpdaterFunction<\n  TData,\n  TVariables extends OperationVariables,\n  TCache extends ApolloCache,\n> = (\n  cache: TCache,\n  result: FormattedExecutionResult<Unmasked<TData>>,\n  options: {\n    context?: DefaultContext;\n    variables?: TVariables;\n  }\n) => void;\n\nexport declare namespace QueryNotification {\n  type NewNetworkStatus = NextNotification<{\n    resetError?: boolean;\n  }> & {\n    source: \"newNetworkStatus\";\n  };\n\n  type SetResult<TData> = NextNotification<ObservableQuery.Result<TData>> & {\n    source: \"setResult\";\n  };\n\n  type FromNetwork<TData> = ObservableNotification<\n    ObservableQuery.Result<TData>\n  > & {\n    source: \"network\";\n  };\n\n  type FromCache<TData> = NextNotification<ObservableQuery.Result<TData>> & {\n    source: \"cache\";\n  };\n\n  type Value<TData> =\n    | FromCache<TData>\n    | FromNetwork<TData>\n    | NewNetworkStatus\n    | SetResult<TData>;\n}\n\n/** Observable created by initiating a subscription operation. */\nexport interface SubscriptionObservable<T> extends Observable<T> {\n  /**\n   * Used to restart the connection to the link chain. Calling this on a\n   * deduplicated subscription will restart the connection for all observables\n   * that share the request.\n   *\n   * @example\n   *\n   * ```ts\n   * const observable = client.subscribe({ query: subscription });\n   * observable.subscribe((value) => {\n   *   // ...\n   * });\n   *\n   * observable.restart();\n   * ```\n   */\n  restart: () => void;\n}\n"]}