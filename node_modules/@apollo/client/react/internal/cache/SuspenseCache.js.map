{"version":3,"file":"SuspenseCache.js","sourceRoot":"","sources":["../../../../src/react/internal/cache/SuspenseCache.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;AASjC,OAAO,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AAC3D,OAAO,EAAE,sBAAsB,EAAE,MAAM,qBAAqB,CAAC;AAiB7D,MAAM,OAAO,aAAa;IAChB,SAAS,GAAG,IAAI,IAAI,EAAwC,CAAC;IAC7D,YAAY,GAAG,IAAI,IAAI,EAAmC,CAAC;IAE3D,OAAO,CAAuB;IAEtC,YAAY,UAAgC,EAAE;QAC5C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED,WAAW,CAIT,QAAkB,EAAE,gBAA8C;QAClE,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,CAE9C,CAAC;QAEF,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;YACjB,GAAG,CAAC,OAAO,GAAG,IAAI,sBAAsB,CAAC,gBAAgB,EAAE,EAAE;gBAC3D,oBAAoB,EAAE,IAAI,CAAC,OAAO,CAAC,oBAAoB;gBACvD,SAAS,EAAE,GAAG,EAAE;oBACd,OAAO,GAAG,CAAC,OAAO,CAAC;gBACrB,CAAC;aACF,CAAC,CAAC;QACL,CAAC;QAED,OAAO,GAAG,CAAC,OAAO,CAAC;IACrB,CAAC;IAED,cAAc,CACZ,QAA0B,EAC1B,MAAoB,EACpB,OAEC;QAED,MAAM,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,QAAQ,CAEjD,CAAC;QAEF,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;YACjB,GAAG,CAAC,OAAO,GAAG,IAAI,iBAAiB,CAAC,MAAM,EAAE,OAAO,EAAE;gBACnD,oBAAoB,EAAE,IAAI,CAAC,OAAO,CAAC,oBAAoB;gBACvD,SAAS,EAAE,GAAG,EAAE;oBACd,OAAO,GAAG,CAAC,OAAO,CAAC;gBACrB,CAAC;aACF,CAAC,CAAC;QACL,CAAC;QAED,OAAO,GAAG,CAAC,OAAO,CAAC;IACrB,CAAC;IAED,GAAG,CAAC,QAAkB,EAAE,QAA0C;QAChE,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QACjD,GAAG,CAAC,OAAO,GAAG,QAAQ,CAAC;IACzB,CAAC;CACF","sourcesContent":["import { Trie } from \"@wry/trie\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  ObservableQuery,\n  OperationVariables,\n} from \"@apollo/client\";\n\nimport { FragmentReference } from \"./FragmentReference.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey, FragmentCacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>();\n  private fragmentRefs = new Trie<{ current?: FragmentReference }>();\n\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = {}) {\n    this.options = options;\n  }\n\n  getQueryRef<\n    TData = unknown,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  >(cacheKey: CacheKey, createObservable: () => ObservableQuery<TData>) {\n    const ref = this.queryRefs.lookupArray(cacheKey) as {\n      current?: InternalQueryReference<TData, TStates>;\n    };\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n\n  getFragmentRef<TData, TVariables extends OperationVariables>(\n    cacheKey: FragmentCacheKey,\n    client: ApolloClient,\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: string;\n    }\n  ) {\n    const ref = this.fragmentRefs.lookupArray(cacheKey) as {\n      current?: FragmentReference<TData, TVariables>;\n    };\n\n    if (!ref.current) {\n      ref.current = new FragmentReference(client, options, {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n\n  add(cacheKey: CacheKey, queryRef: InternalQueryReference<any, any>) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n    ref.current = queryRef;\n  }\n}\n"]}